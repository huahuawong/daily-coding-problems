#1 Let's say if we want to move the zeroes in an array to the back of an array

def moveZerosToEnd(arr, n):
    count = 0
    for i in range(n):
        if arr[i] != 0:
            arr[count] = arr[i]
            count += 1

    while count < n:
        arr[count] = 0
        count += 1

    return arr

# Drive code
arr = [1, 10, 0, 2, 8, 3, 0, 0, 6, 4, 0, 5, 7, 0, 0, 8, 9, 7]
n = len(arr)
print(moveZerosToFront(arr, n))


###########################################################################################################################################
#2 Situation is reversed, bring the zeroes to the front

def moveZerosToFront(arr, n):
    count = 0
    for i in range(n):
        if arr[i] != 0:
            arr[count] = arr[i]
            count += 1

    for i in range(count, n-1):
        arr.pop()

    while count < n:
        var = 0
        arr.insert(0, var)
        count += 1

    return arr
    
# Driver code
arr = [1, 10, 0, 2, 8, 3, 0, 0, 6, 4, 0, 5, 7, 0, 0, 8, 9, 7]
n = len(arr)
print(moveZerosToFront(arr, n))

###########################################################################################################################################

#3 Given an array, rotate the array to the right by k steps, where k is non-negative.

For example:
Input: [1,2,3,4,5,6,7] and k = 3
Output: [5,6,7,1,2,3,4]

input = [1, 2, 3, 4, 5, 6, 7]
k = 3


def rotate_input(arr):
    pop_arr = []
    for i in range(0, k):
        pop_var = arr.pop()
        pop_arr.insert(0, pop_var)

    output = pop_arr + arr

    return output


print(rotate_input(input))


Or even easier:

def rotate(nums, k):
      n = len(nums)
      k = k % n
      nums[:] = nums[n-k:] + nums[:n-k]

      return nums

###########################################################################################################################################


#4 Given a m x n matrix, if an element is 0, set its entire row and column to 0.


def setZeroes(self, matrix):
        isCol = False
        R = len(matrix)   #get length of row
        C = len(matrix[0])  #get length of column
        
        for i in range(R):
            if matrix[i][0] == 0:    #which means matrix[0][0] is 0, so isCol would be true, making all the values in column 0, zero
                isCol = True
            for j in range(1, C):
                if matrix[i][j] == 0:
                    matrix[0][j] = 0    #if found zero, set the first element of the corresponding row and column to 0
                    matrix[i][0] = 0
        
        for i in range(1, R):           #continue updating the zeroes
            for j in range(1, C):
                if not matrix[i][0] or not matrix[0][j]:
                    matrix[i][j]=0
                    
        if matrix[0][0] == 0:           #to make all the element in the first row zero
            for j in range(C):
                matrix[0][j] = 0
                
        if isCol:                       #to make all the element on the first column zero
            for i in range(R):
                matrix[i][0] = 0
        
        
#Driver code
matrix = [[0,1,2,0],[3,4,5,2], [1,3,1,5]]

###########################################################################################################################################

#5 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).

You are given a target value to search. If found in the array return its index, otherwise return -1.
You may assume no duplicate exists in the array.

Easiest way to do it is searching the array one by one, Alternative way is binary search, which is harder. Let's do binary.

def Binarysearch(nums, target)

    if not nums:
        return -1

    low, high = 0, len(nums) - 1  #first, we get the high and low point
    middle = (low + high)/2       #and then we get the middle point
    if nums[mid] == target:
        return mid
    
    if nums[low] <= nums[mid]:    #recall that this is a sorted array, so if nums[mid] is larger than nums[low] means that target should be at 
        if nums[low] <= target <= nums[mid]:    #the left hand side
            high = mid - 1
        else:
            low = mid + 1
    else:
        if nums[mid] <= target <= nums[high]:
            low = mid + 1
        else:
                high = mid - 1

        return -1
    
    
###########################################################################################################################################
    




